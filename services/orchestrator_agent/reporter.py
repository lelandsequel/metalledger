"""
MetalLedger — Orchestrator markdown report generator.

On each scheduled run:
  1. Queries latest forecasts for all metals from DB
  2. Generates a markdown report
  3. Writes to /reports/YYYY-MM-DD_<metal>.md (one file per metal)
  4. Stores report metadata in a policy_events row (as the report is an agent action)
"""

from __future__ import annotations

import os
import sys
from datetime import datetime, timezone
from typing import Any, Optional

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", "packages"))

from common.audit import write_audit_entry_async, new_request_id
from common.config import REPORTS_DIR
from common.logging_util import get_logger

log = get_logger("orchestrator.reporter")

METALS = ["XAU", "XAG", "CU"]

METAL_NAMES = {
    "XAU": "Gold (XAU)",
    "XAG": "Silver (XAG)",
    "CU":  "Copper (CU)",
}


async def _fetch_latest_forecasts(pool: Any, metal: str) -> list:
    """Fetch latest forecast rows for a metal."""
    try:
        rows = await pool.fetch(
            """
            SELECT DISTINCT ON (model, horizon)
                model, metal, horizon, run_at, p10, p50, p90
            FROM forecasts
            WHERE metal = $1
            ORDER BY model, horizon, run_at DESC
            """,
            metal,
        )
        return [dict(r) for r in rows]
    except Exception as exc:
        log.error("Failed to fetch forecasts for %s: %s", metal, exc)
        return []


async def _fetch_latest_price(pool: Any, metal: str) -> Optional[float]:
    """Fetch the most recent canonical price."""
    try:
        row = await pool.fetchrow(
            """
            SELECT value FROM prices_canonical
            WHERE metal = $1
            ORDER BY price_ts DESC
            LIMIT 1
            """,
            metal,
        )
        return float(row["value"]) if row else None
    except Exception as exc:
        log.error("Failed to fetch price for %s: %s", metal, exc)
        return None


def _format_forecast_table(forecasts: list) -> str:
    """Render forecasts as a markdown table."""
    if not forecasts:
        return "_No forecast data available._\n"

    # Group by model
    by_model: dict[str, dict[int, dict]] = {}
    for f in forecasts:
        by_model.setdefault(f["model"], {})[f["horizon"]] = f

    lines = ["| Model | H=1d P50 | H=5d P50 | H=20d P50 | H=1d P10–P90 |",
             "|-------|----------|----------|-----------|--------------|"]

    for model, horizons in sorted(by_model.items()):
        p50_1  = horizons.get(1,  {}).get("p50")
        p50_5  = horizons.get(5,  {}).get("p50")
        p50_20 = horizons.get(20, {}).get("p50")
        p10_1  = horizons.get(1,  {}).get("p10")
        p90_1  = horizons.get(1,  {}).get("p90")

        def fmt(v):
            return f"${float(v):,.2f}" if v is not None else "—"

        range_1d = f"{fmt(p10_1)} – {fmt(p90_1)}" if p10_1 and p90_1 else "—"

        lines.append(
            f"| {model:<14} | {fmt(p50_1)} | {fmt(p50_5)} | {fmt(p50_20)} | {range_1d} |"
        )

    return "\n".join(lines) + "\n"


def generate_report(
    metal: str,
    spot_price: Optional[float],
    forecasts:  list,
    run_at:     datetime,
) -> str:
    """Generate a full markdown report for a single metal."""
    date_str   = run_at.strftime("%Y-%m-%d")
    metal_name = METAL_NAMES.get(metal, metal)
    spot_fmt   = f"${spot_price:,.2f}" if spot_price else "N/A"

    table_md = _format_forecast_table(forecasts)

    report = f"""# MetalLedger Forecast Report — {metal_name}

**Date:** {date_str}
**Generated by:** orchestrator_agent (automated)
**Spot Price (latest canonical):** {spot_fmt}

---

## Forecast Summary

{table_md}

---

## Guardrails Status

| Guardrail | Status |
|-----------|--------|
| Agent cannot modify journal entries | ✅ Enforced (policy.py) |
| Source config changes require approval | ✅ Enforced (policy.py) |
| Egress via allowlist only | ✅ Enforced (egress.py) |
| All actions audit-logged | ✅ Enforced (audit.py) |

---

## Notes

- P10/P90 represent the 10th and 90th percentile price estimates.
- P50 is the median (central) forecast.
- Horizons: 1 day, 5 days (1 week), 20 days (~1 month).
- ARIMA uses 5,1,0 order (or auto-selected via pmdarima if available).
- GradientBoost uses quantile regression with lag features.
- Forecasts are probabilistic estimates, not financial advice.

---

*Generated at {run_at.isoformat()} UTC*
"""
    return report.strip()


async def generate_and_store_report(pool: Any, forecast_result: dict) -> None:
    """
    Generate markdown reports for all metals, store to disk + audit log.
    """
    run_at     = datetime.now(tz=timezone.utc)
    request_id = new_request_id()

    # Ensure reports directory exists
    os.makedirs(REPORTS_DIR, exist_ok=True)

    reports_written = []

    for metal in METALS:
        spot_price = await _fetch_latest_price(pool, metal)
        forecasts  = await _fetch_latest_forecasts(pool, metal)

        if not forecasts:
            log.info("No forecasts for %s — skipping report", metal)
            continue

        report_md = generate_report(metal, spot_price, forecasts, run_at)

        # Write to disk
        filename = f"{run_at.strftime('%Y-%m-%d')}_{metal}.md"
        filepath = os.path.join(REPORTS_DIR, filename)
        try:
            with open(filepath, "w") as f:
                f.write(report_md)
            log.info("Report written: %s", filepath)
            reports_written.append(filepath)
        except OSError as exc:
            log.error("Could not write report %s: %s", filepath, exc)

    # Audit the report generation
    await write_audit_entry_async(
        pool,
        request_id = request_id,
        actor      = "agent",
        action     = "generate_reports",
        payload    = {
            "run_at":          run_at.isoformat(),
            "reports_written": len(reports_written),
            "forecast_result": forecast_result,
        },
    )

    log.info("Report generation complete: %d reports", len(reports_written))
